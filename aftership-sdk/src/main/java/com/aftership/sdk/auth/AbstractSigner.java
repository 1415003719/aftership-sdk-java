package com.aftership.sdk.auth;

import lombok.Data;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

@Data
public abstract class AbstractSigner {
  private String secret;

  protected AbstractSigner(String secret) {
    this.secret = secret;
  }

  protected abstract SignHeader getHeader(String signString);


  /**
   * Calculate the signature
   * @param content The Sign is generated by Method, Uri, Headers, Body from a HTTP(s) request.
   * @return
   */
  public SignHeader sign(SignatureContent content) {
    String signString;
    try {
      URL url = new URL(content.getUrlStr());
      signString = this.getSignString(
        content.getMethod(), content.getBody(), content.getContentType(), content.getDate(),
        this.getCanonicalizedAmHeaders(content.getHeaders()), this.getCanonicalizedResource(url));
    } catch (MalformedURLException e) {
      throw new RuntimeException(e);
    }
    return this.getHeader(signString);
  }

  /**
   * The SignString is constructed by concatenating all the required keys with the new line character (ASCII code 10).
   * @param method
   * @param body
   * @param contentType
   * @param date
   * @param canonicalizedAmHeaders
   * @param canonicalizedResource
   * @return
   */
  private String getSignString(String method, String body, String contentType, String date, String canonicalizedAmHeaders, String canonicalizedResource) {
    StringBuilder buffer = new StringBuilder();
    buffer.append(method);
    buffer.append("\n");
    if (body == null) {
      body = "";
    }
    if (!body.equals("")) {
      body = getMD5Str(body).toUpperCase();
    } else {
      contentType = "";
    }
    buffer.append(body).append("\n");
    buffer.append(contentType).append("\n");
    buffer.append(date).append("\n");
    buffer.append(canonicalizedAmHeaders).append("\n");
    buffer.append(canonicalizedResource);
    return buffer.toString();
  }

  /**
   * Extract all request headers with the as- prefix key. Kindly note that the headers with the as- prefix are not limited to as-api-key or as-signature-*, but also include other as- prefixed key such as as-store-id.
   * Convert all the request header key to lowercase (except the header values case), and sort the headers in ASCII code order.
   * Concatenate each of the header key and value with :, to form a header pair
   * Concatenate all header pairs with the new line character (ASCII code 10).
   * If no customized header is provided, set canonicalized_headers to an empty string
   * @param headers all request headers with the as- prefix key.
   * @return CANONICALIZED_HEADERS string
   */
  private String getCanonicalizedAmHeaders(Map<String, String> headers) {
    List<String> sortedHeaders = new ArrayList<>(headers.keySet());
    StringBuilder buffer = new StringBuilder();
    sortedHeaders.sort(String.CASE_INSENSITIVE_ORDER);
    for (String key : sortedHeaders) {
      String newKey = key.toLowerCase();
      // only support header with as- prefix
      if (!newKey.startsWith("as-")) {
        continue;
      }
      String value = headers.get(key);
      buffer.append(newKey);
      buffer.append(":");
      if (value != null) {
        buffer.append(value);
      }
      buffer.append("\n");
    }
    return buffer.toString().trim();
  }

  /**
   * If there is any parameter, it should be appended to the path.
   * The parameters should be sorted by the ASCII code of the key in ascending order, and parameters with duplicate names should be sorted by the value.
   * @param url Resource Uri
   * @return the path of the URL, including the query parameters.
   */
  private String getCanonicalizedResource(URL url) {
    StringBuilder buffer = new StringBuilder();
    buffer.append(url.getPath());
    String query = url.getQuery();
    if (query == null) {
      return buffer.toString();
    }
    String[] params = query.split("&");
    Arrays.sort(params);
    String queryStr = String.join("&", params);
    buffer.append("?");
    buffer.append(queryStr);
    return buffer.toString();
  }


  private String getMD5Str(String str) {
    String result = "";
    try {
      MessageDigest md5 = MessageDigest.getInstance("md5");
      byte[] digest = md5.digest(str.getBytes(StandardCharsets.UTF_8));

      StringBuilder sb = new StringBuilder();
      for (byte b : digest) {
        sb.append(String.format("%02x", b & 0xff));
      }
      result = sb.toString();
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
    return result;
  }
}
